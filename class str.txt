Справка по классу str в модуле builtins:

class str(object)
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str
 
Создать новый строковый объект из заданного объекта. Если указаны кодировка или
указаны ошибки, то объект должен представлять буфер данных
который будет декодирован с использованием заданной кодировки и обработчика ошибок.
В противном случае возвращается результат object.__str__() (если определено)
или repr(object).
Кодировка по умолчанию - sys.getdefaultencoding().
Ошибки по умолчанию имеют значение 'strict'.
 

Методы, определенные здесь:
  
capitalize(self, /)
    Возвращает капитализированную версию строки.
    Точнее, сделать так, чтобы первый символ был в верхнем регистре, а остальные - в нижнем.
    
    line = 'PYTHON python-Python'
    print(line.capitalize())
    # Python python-python

casefold(self, /)
    Возвращает версию строки, пригодную для сравнения без регистра.
 
center(self, width, fillchar=' ', /)
    Возвращает центрированную строку длины width.
    Вставка выполняется с помощью указанного символа заполнения (по умолчанию это пробел).
 
count(...)
    S.count(sub[, start[, end]]) -> int
    Возвращает количество непересекающихся вхождений подстроки sub в
    строке S[начало:конец].  Необязательные аргументы start и end
    интерпретируются как в нотации срезов.
 
encode(self, /, encoding='utf-8', errors='strict')
    Кодирует строку, используя кодек, зарегистрированный для кодирования.
    encoding
        Кодировка, в которой следует кодировать строку.
    errors
        Схема обработки ошибок, которую следует использовать для ошибок кодирования.
        По умолчанию используется значение 'strict', означающее, что ошибки кодирования вызывают ошибку
        UnicodeEncodeError.  Другие возможные значения: 'ignore', 'replace' и
        'xmlcharrefreplace', а также любое другое имя, зарегистрированное с помощью функции
        codecs.register_error, которые могут обрабатывать UnicodeEncodeErrors.

endswith(...)
    S.endswith(suffix[, start[, end]]) -> bool
    Возвращает True, если S заканчивается указанным суффиксом, False в противном случае.
    При необязательном begin, проверяется S, начинающийся с этой позиции.
    При необязательном end, прекратить сравнение S в этой позиции.
    Суффикс также может быть кортежем строк для проверки.
 
expandtabs(self, /, tabsize=8)
    Возвращает копию, в которой все символы табуляции расширены с помощью пробелов.
    Если tabsize не задан, предполагается, что размер табуляции равен 8 символам.
    
find(...)
    S.find(sub[, start[, end]]) -> int
    Возвращает наименьший индекс в S, в котором найдена подстрока sub,
    такой, что sub содержится в S[start:end].  Необязательно
    Аргументы start и end интерпретируются как в нотации slice.
    При неудаче возвращается -1.
     
format(...)
    S.format(*args, **kwargs) -> str
    Возвращает форматированную версию S, используя подстановки из args и kwargs.
    Замены обозначаются скобками ('{' и '}').
 
format_map(...)
    S.format_map(mapping) -> str
    Возвращает форматированную версию S, используя подстановки из отображения.
    Замены обозначаются скобками ('{' и '}').
 
index(...)
    S.index(sub[, start[, end]]) -> int
    Возвращает наименьший индекс в S, в котором найдена подстрока sub,
    такой, что sub содержится в S[start:end]. Необязательно
    Аргументы start и end интерпретируются как в нотации slice.
    Вызывает ошибку ValueError, если подстрока не найдена.

isalnum(self, /)
    Возвращает True, если строка является буквенно-цифровой, False в противном случае.
    Строка является буквенно-цифровой, если все символы в строке буквенно-цифровые 
    и в строке есть хотя бы один символ.

isalpha(self, /)
    Возвращает True, если строка является алфавитной, False в противном случае.
    Строка является алфавитной, если все символы в строке алфавитные и в строке есть хотя бы один символ.

isascii(self, /)
    Возвращает True, если все символы в строке являются ASCII, False в противном случае.
    Символы ASCII имеют кодовые точки в диапазоне U+0000-U+007F.
    Пустая строка также является ASCII.

isdecimal(self, /)
    Возвращает True, если строка является десятичной, False в противном случае.
    Строка является десятичной, если все символы в строке десятичные и
    В строке есть хотя бы один символ.

isdigit(self, /)
    Возвращает True, если строка является цифровой строкой, False в противном случае.
    Строка является цифровой, если все символы в строке являются цифрами и в строке есть хотя бы один символ.

isidentifier(self, /)
    Возвращает True, если строка является допустимым идентификатором Python, False в противном случае.
    Вызов keyword.iskeyword(s) для проверки того, является ли строка s зарезервированным идентификатором,
    например, "def" или "class".

islower(self, /)
    Возвращает True, если строка является строчной, False в противном случае.
    Строка является строчной, если все латинские символы в строке являются строчными и
    в строке есть хотя бы один символ в нижнем регистре.

isnumeric(self, /)
    Возвращает True, если строка является числовой, False в противном случае.
    Строка является числовой, если все символы в строке являются числовыми и в строке есть по крайней мере
    хотя бы один символ.

isprintable(self, /)
    Возвращает True, если строка пригодна для печати, False в противном случае.
    Строка является печатаемой, если все ее символы считаются печатаемыми в функции
    repr() или если она пуста.

isspace(self, /)
    Возвращает True, если строка является строкой с пробелами, False в противном случае.
    Строка является пробельной, если все символы в ней пробельные и в строке есть хотя бы один символ.

istitle(self, /)
    Возвращает True, если строка является строкой с заголовком, False в противном случае.
    В строке с заголовком символы верхнего и заглавного регистра могут следовать только за символами без регистра, 
    а символы нижнего регистра - только за символами с регистром.

isupper(self, /)
    Возвращает True, если строка является строкой в верхнем регистре, False в противном случае.
    Строка является прописной, если все латинские символы в строке прописные и
    в строке есть хотя бы один символ в верхнем регистре.

join(self, iterable, /)
    Конкатенировать любое количество строк.
    Строка, метод которой вызывается, вставляется между каждой заданной строкой.
    Результат возвращается в виде новой строки.
    Пример: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'

ljust(self, width, fillchar=' ', /)
    Возвращает выровненную по левому краю строку длиной width.
    Вставка выполняется с использованием указанного символа заполнения (по умолчанию это пробел).

lower(self, /)
    Возвращает копию строки, преобразованную в нижний регистр.

lstrip(self, chars=None, /)
    Возвращает копию строки с удаленными пробелами.
    Если задано chars, а не None, удалите символы chars.

partition(self, sep, /)
    Разделить строку на три части с помощью заданного разделителя.
    Это выполнит поиск разделителя в строке. Если разделитель найден,
    возвращается кортеж из трех частей, содержащий часть перед разделителем, сам разделитель
    и часть после него.
    Если разделитель не найден, возвращается 3-кортеж, содержащий исходную строку
    и две пустые строки.

replace(self, old, new, count=-1, /)
    Возвращает копию, в которой все вхождения подстроки old заменены на new.
        count
            Максимальное количество вхождений для замены.
            -1 (значение по умолчанию) означает замену всех вхождений.
    Если указан необязательный аргумент count, то заменяются только первые по счету вхождения.

rfind(...)
    S.rfind(sub[, start[, end]]) -> int
    Возвращает наибольший индекс в S, в котором найдена подстрока sub,
    такой, что sub содержится в S[start:end]. Необязательно
    Аргументы start и end интерпретируются как в нотации slice.
    При неудаче возвращается -1.

rindex(...)
    S.rindex(sub[, start[, end]]) -> int
    Возвращает наибольший индекс в S, в котором найдена подстрока sub,
    такой, что sub содержится в S[start:end]. Необязательно
    Аргументы start и end интерпретируются как в нотации slice.
    Вызывает ошибку ValueError, если подстрока не найдена.

rjust(self, width, fillchar=' ', /)
    Возвращает выровненную по правому краю строку длиной width.
    Вставка выполняется с использованием указанного символа заполнения (по умолчанию пробел).

rpartition(self, sep, /)
    Разделите строку на три части с помощью заданного разделителя.
    Это приведет к поиску разделителя в строке, начиная с конца. Если
    разделитель найден, возвращается кортеж из трех частей, содержащий 
    часть перед разделителем, сам разделитель и часть после него.
    Если разделитель не найден, возвращается кортеж, содержащий две пустые строки
    и исходную строку.

rsplit(self, /, sep=None, maxsplit=-1)
    Возвращает список слов в строке, используя sep в качестве строки-разделителя.
    sep
        Разделитель, по которому нужно разделить строку.
        None (значение по умолчанию) означает разделение по любому пробелу,
        и отбрасывает пустые строки из результата.
    maxsplit
        Максимальное количество разбиений.
        -1 (значение по умолчанию) означает отсутствие ограничений.
    Разбиение выполняется, начиная с конца строки и до конца.

rstrip(self, chars=None, /)
    Возвращает копию строки с удаленными пробелами.
    Если задано chars, а не None, вместо этого удаляются символы в chars.

split(self, /, sep=None, maxsplit=-1)
    Возвращает список слов в строке, используя sep в качестве строки-разделителя. 
    sep
        Разделитель, по которому нужно разделить строку.
        None (значение по умолчанию) означает разделение по любому пробелу,
        и отбрасывает пустые строки из результата.
    maxsplit
        Максимальное количество разбиений.
        -1 (значение по умолчанию) означает отсутствие ограничений.

splitlines(self, /, keepends=False)
    Возвращает список строк в строке, разрываясь на границах строк.     
    Разрывы строк не включаются в результирующий список, если не задано значение keepends и
    true.

startswith(...)
    S.startswith(prefix[, start[, end]]) -> bool  
    Возвращает True, если S начинается с указанного префикса, False в противном случае.
    При необязательном begin, проверяется S, начинающийся с этой позиции.
    При необязательном end, прекратить сравнение S в этой позиции.
    Префикс также может быть кортежем строк для проверки.

strip(self, chars=None, /)
    Возвращает копию строки с удаленными пробелами в начале и конце.
    Если задано chars, а не None, вместо этого удаляются символы в chars.

swapcase(self, /)
    Преобразование символов верхнего регистра в нижний и нижнего регистра в верхний.
 
title(self, /)
    Возвращает версию строки, в которой каждое слово написано в заголовке.
    Точнее говоря, слова начинаются с прописных символов, а все остальные символы
    и все остальные символы в нижнем регистре.

translate(self, table, /)
    Заменяет каждый символ в строке, используя заданную таблицу перевода.
    table
        Таблица перевода, которая должна быть отображением ординалов Юникода на
        ординалов Юникода, строк или None.
    Таблица должна реализовывать поиск/индексацию через __getitem__, например.
    словарь или список.  Если эта операция вызывает ошибку LookupError, символ
    остается нетронутым.  Символы, сопоставленные с None, удаляются.

upper(self, /)
    Возвращает копию строки, преобразованную в верхний регистр.

zfill(self, width, /)
    Заполнить числовую строку нулями слева, чтобы заполнить поле заданной ширины.
    Строка никогда не усекается.

----------------------------------------------------------------------
Здесь определены статические методы:
 
__new__(*args, **kwargs) из builtins.type
     Создает и возвращает новый объект.  Точную сигнатуру смотрите в help(type).
 
maketrans(...)
    Возвращает таблицу переводов, используемую для str.translate().
         
    Если аргумент только один, он должен быть словарем, отображающим ординаты 
    (целые числа или символы) Юникода в символы Юникода.
    ординалов (целых чисел) или символов к ординалам Unicode, строкам или None.
    Символьные ключи будут преобразованы в ординалы.
    Если аргументов два, они должны быть строками одинаковой длины, и
    В результирующем словаре каждый символ в x будет сопоставлен с символом в
    символу в той же позиции в y. Если есть третий аргумент, то он
    должен быть строкой, символы которой будут отображены на None в результате.